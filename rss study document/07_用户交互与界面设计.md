# 用户交互与界面设计

## 📚 本文档目标

深入学习 RSS 项目中的用户交互设计和命令行界面开发，理解如何构建用户友好的终端应用。通过本文档，你将：

- 掌握命令行界面（CLI）设计的最佳实践
- 学会处理用户输入和数据验证
- 理解如何设计直观的菜单系统
- 掌握输出格式化和美化技术
- 了解用户体验（UX）设计原则
- 学会实现国际化和本地化

## 🎨 命令行界面设计原则

### 1. 用户体验（UX）设计原则

RSS 项目体现了良好的 CLI 设计原则：

**清晰的信息层次结构**：
```python
# rss_reader.py 第 209-217 行
print("\n" + "=" * 50)
print("📱 主菜单")
print("=" * 50)
print("[1] 查看订阅源列表")
print("[2] 添加订阅源")
print("[3] 删除订阅源")
print("[4] 阅读订阅")
print("[5] 退出程序")
print("=" * 50)
```

**友好的视觉提示**：
```python
# 使用表情符号增强用户体验
print("✅ 已加载 {len(self.subscriptions)} 个订阅源")
print("❌ 网络请求失败")
print("⚠️  配置文件读取错误")
print("🆕 首次使用，将创建新的订阅配置")
```

### 2. CLI 设计最佳实践

#### 一致性原则
```python
# 保持操作反馈的一致性
def show_success(message):
    print(f"✅ {message}")

def show_error(message):
    print(f"❌ {message}")

def show_warning(message):
    print(f"⚠️  {message}")

def show_info(message):
    print(f"ℹ️  {message}")
```

#### 可预测性原则
```python
# 用户应该能够预测操作的结果
class MenuManager:
    def show_menu(self, title, options, prompt="请选择"):
        """标准化的菜单显示"""
        print(f"\n{'=' * 50}")
        print(f"{title}")
        print(f"{'=' * 50}")
        
        for i, option in enumerate(options, 1):
            print(f"[{i}] {option}")
        
        print(f"{'=' * 50}")
        return input(f"{prompt}: ").strip()
```

## 🖥️ 输入处理与验证

### 1. 用户输入获取

RSS 项目中的输入处理：

```python
# rss_reader.py 第 219 行
choice = input("请选择操作 (1-5): ").strip()

# 第 226-227 行
name = input("请输入订阅源名称 (留空将自动获取): ").strip()
url = input("请输入 RSS 链接: ").strip()
```

### 2. 输入验证和清理

**基础输入验证**：
```python
def get_user_choice(prompt, valid_choices):
    """获取并验证用户选择"""
    while True:
        choice = input(prompt).strip().lower()
        if choice in valid_choices:
            return choice
        print(f"❌ 无效选择，请输入: {', '.join(valid_choices)}")

# 使用示例
choice = get_user_choice("请选择操作 (y/n): ", ['y', 'n', 'yes', 'no'])
```

**数字输入验证**：
```python
def get_integer_input(prompt, min_value=None, max_value=None):
    """获取整数输入"""
    while True:
        try:
            value = int(input(prompt).strip())
            
            if min_value is not None and value < min_value:
                print(f"❌ 值不能小于 {min_value}")
                continue
            
            if max_value is not None and value > max_value:
                print(f"❌ 值不能大于 {max_value}")
                continue
            
            return value
            
        except ValueError:
            print("❌ 请输入有效的数字")

# 使用示例
max_articles = get_integer_input("请输入最大文章数 (1-50): ", 1, 50)
```

**URL 输入验证**：
```python
import re
from urllib.parse import urlparse

def get_url_input(prompt):
    """获取并验证 URL 输入"""
    url_pattern = re.compile(
        r'^https?://'  # http:// or https://
        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+[A-Z]{2,6}\.?|'  # domain...
        r'localhost|'  # localhost...
        r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})'  # ...or ip
        r'(?::\d+)?'  # optional port
        r'(?:/?|[/?]\S+)$', re.IGNORECASE)
    
    while True:
        url = input(prompt).strip()
        
        if not url:
            print("❌ URL 不能为空")
            continue
        
        if not url_pattern.match(url):
            print("❌ 请输入有效的 URL（必须以 http:// 或 https:// 开头）")
            continue
        
        # 进一步验证 URL 结构
        try:
            parsed = urlparse(url)
            if not parsed.netloc:
                print("❌ URL 格式无效")
                continue
        except Exception:
            print("❌ URL 解析失败")
            continue
        
        return url

# 使用示例
rss_url = get_url_input("请输入 RSS 链接: ")
```

### 3. 高级输入处理

**带默认值的输入**：
```python
def get_input_with_default(prompt, default=None):
    """获取输入，支持默认值"""
    if default:
        full_prompt = f"{prompt} [默认: {default}]: "
    else:
        full_prompt = f"{prompt}: "
    
    value = input(full_prompt).strip()
    return value if value else default

# 使用示例
name = get_input_with_default("请输入订阅源名称", "默认名称")
timeout = get_input_with_default("请输入超时时间（秒）", 10)
```

**多行输入处理**：
```python
def get_multiline_input(prompt):
    """获取多行输入"""
    print(f"{prompt} (输入空行结束):")
    lines = []
    while True:
        line = input()
        if not line.strip():
            break
        lines.append(line)
    return '\n'.join(lines)

# 使用示例
description = get_multiline_input("请输入订阅源描述")
```

## 📋 菜单系统设计

### 1. 分层菜单结构

RSS 项目使用分层菜单设计：

```python
# 主菜单 -> 子菜单 -> 操作
def main_menu(self):
    """主菜单"""
    # 显示主菜单选项
    pass

def read_feed(self, subscription_name):
    """阅读菜单（子菜单）"""
    # 第 178-202 行
    while True:
        print("\n🔧 操作选项:")
        print("  [1-{}] 在浏览器中打开对应文章".format(len(articles)))
        print("  [r] 刷新文章列表")
        print("  [b] 返回主菜单")
        
        choice = input("\n请选择操作: ").strip().lower()
        # 处理选择...
```

### 2. 菜单系统的高级设计

**面向对象的菜单系统**：
```python
from abc import ABC, abstractmethod
from typing import Dict, List, Callable

class MenuItem:
    """菜单项"""
    def __init__(self, key: str, title: str, action: Callable, description: str = ""):
        self.key = key
        self.title = title
        self.action = action
        self.description = description

class Menu:
    """菜单类"""
    def __init__(self, title: str, prompt: str = "请选择"):
        self.title = title
        self.prompt = prompt
        self.items: Dict[str, MenuItem] = {}
        self.auto_numbered = True
    
    def add_item(self, key: str, title: str, action: Callable, description: str = ""):
        """添加菜单项"""
        self.items[key] = MenuItem(key, title, action, description)
    
    def add_separator(self):
        """添加分隔符"""
        separator_key = f"sep_{len(self.items)}"
        self.items[separator_key] = MenuItem(separator_key, "---", None)
    
    def show(self):
        """显示菜单"""
        print(f"\n{'=' * 60}")
        print(f"{self.title:^60}")
        print(f"{'=' * 60}")
        
        # 显示菜单项
        numbered_items = []
        for key, item in self.items.items():
            if item.title == "---":
                print(f"{'-' * 60}")
            else:
                if self.auto_numbered:
                    if key.isdigit():
                        print(f"[{key}] {item.title}")
                    else:
                        print(f"[{key.upper()}] {item.title}")
                    if item.description:
                        print(f"    {item.description}")
                else:
                    print(f"{item.title}")
        
        print(f"{'=' * 60}")
        return input(f"{self.prompt}: ").strip()
    
    def handle_choice(self, choice: str):
        """处理用户选择"""
        choice = choice.lower()
        
        if choice in self.items:
            item = self.items[choice]
            if item.action:
                return item.action()
        
        print("❌ 无效选择")
        return None

# 使用菜单系统的 RSS 阅读器
class MenuBasedRSSReader:
    def __init__(self):
        self.subscriptions = {}
        self.current_articles = []
        self.setup_menus()
    
    def setup_menus(self):
        """设置菜单"""
        # 主菜单
        self.main_menu = Menu("📱 RSS 阅读器主菜单")
        self.main_menu.add_item("1", "查看订阅源列表", self.list_subscriptions)
        self.main_menu.add_item("2", "添加订阅源", self.add_subscription)
        self.main_menu.add_item("3", "删除订阅源", self.remove_subscription)
        self.main_menu.add_item("4", "阅读订阅", self.select_subscription_to_read)
        self.main_menu.add_separator()
        self.main_menu.add_item("h", "帮助", self.show_help)
        self.main_menu.add_item("q", "退出", self.quit_application)
        
        # 阅读菜单
        self.reading_menu = Menu("📰 阅读选项")
        self.reading_menu.add_item("r", "刷新文章列表", self.refresh_articles)
        self.reading_menu.add_item("s", "搜索文章", self.search_articles)
        self.reading_menu.add_item("b", "返回主菜单", lambda: "back")
    
    def run(self):
        """运行程序"""
        while True:
            choice = self.main_menu.show()
            result = self.main_menu.handle_choice(choice)
            if result == "quit":
                break

    def list_subscriptions(self):
        """列出订阅源"""
        if not self.subscriptions:
            print("📭 暂无订阅源")
            return
        
        print("\n📚 当前订阅源:")
        for i, (name, url) in enumerate(self.subscriptions.items(), 1):
            print(f"  [{i}] {name}")
            print(f"      🔗 {url}")
    
    def quit_application(self):
        print("👋 感谢使用，再见!")
        return "quit"
```

### 3. 动态菜单生成

```python
def create_subscription_menu(subscriptions: dict) -> Menu:
    """根据订阅源动态创建菜单"""
    menu = Menu("📖 选择要阅读的订阅源")
    
    for i, (name, url) in enumerate(subscriptions.items(), 1):
        menu.add_item(str(i), name, lambda n=name: read_subscription(n))
    
    menu.add_separator()
    menu.add_item("b", "返回主菜单", lambda: "back")
    
    return menu
```

## 🎨 输出格式化与美化

### 1. 文本格式化

RSS 项目中的格式化示例：

```python
# 第 144-161 行：文章显示格式化
print(f"\n📰 最新文章 (共 {len(articles)} 篇):")
print("=" * 70)

for i, article in enumerate(articles, 1):
    print(f"\n[{i}] {article['title']}")
    print(f"📅 {article['published']}")
    
    # 截取摘要
    summary = article['summary']
    if len(summary) > 200:
        summary = summary[:200] + "..."
    
    print(f"📝 {summary}")
    print(f"🔗 {article['link']}")
    print("-" * 70)
```

### 2. 高级格式化技术

**表格式输出**：
```python
def print_table(data, headers, max_width=80):
    """打印表格"""
    if not data:
        print("📭 无数据")
        return
    
    # 计算列宽
    col_widths = [len(header) for header in headers]
    for row in data:
        for i, cell in enumerate(row):
            col_widths[i] = max(col_widths[i], len(str(cell)))
    
    # 调整列宽以适应最大宽度
    total_width = sum(col_widths) + len(headers) - 1
    if total_width > max_width:
        # 按比例缩小列宽
        scale_factor = (max_width - len(headers) + 1) / sum(col_widths)
        col_widths = [int(w * scale_factor) for w in col_widths]
    
    # 打印表头
    header_line = " | ".join(h.ljust(w) for h, w in zip(headers, col_widths))
    print(header_line)
    print("-" * len(header_line))
    
    # 打印数据行
    for row in data:
        row_line = " | ".join(str(cell).ljust(w)[:w] for cell, w in zip(row, col_widths))
        print(row_line)

# 使用示例
subscription_data = [
    ["BBC News", "https://feeds.bbci.co.uk/news/rss.xml", "新闻"],
    ["Python 官方", "https://blog.python.org/feeds/posts/default?alt=rss", "技术"]
]
print_table(subscription_data, ["名称", "URL", "分类"])
```

**颜色输出**（使用 colorama 库）：
```python
from colorama import init, Fore, Back, Style
import sys

# 初始化 colorama（Windows 兼容性）
init(autoreset=True)

class ColoredOutput:
    """彩色输出辅助类"""
    
    @staticmethod
    def success(message):
        print(f"{Fore.GREEN}✅ {message}{Style.RESET_ALL}")
    
    @staticmethod
    def error(message):
        print(f"{Fore.RED}❌ {message}{Style.RESET_ALL}")
    
    @staticmethod
    def warning(message):
        print(f"{Fore.YELLOW}⚠️  {message}{Style.RESET_ALL}")
    
    @staticmethod
    def info(message):
        print(f"{Fore.BLUE}ℹ️  {message}{Style.RESET_ALL}")
    
    @staticmethod
    def header(message):
        print(f"{Fore.MAGENTA}{Style.BRIGHT}{'=' * 60}")
        print(f"{message:^60}")
        print(f"{'=' * 60}{Style.RESET_ALL}")

# 使用示例
ColoredOutput.success("订阅源添加成功")
ColoredOutput.error("网络连接失败")
ColoredOutput.header("RSS 阅读器")
```

**进度条显示**：
```python
import sys
import time

def show_progress(current, total, prefix="进度", suffix="完成", length=50):
    """显示进度条"""
    percent = current / total
    filled_length = int(length * percent)
    bar = "█" * filled_length + "-" * (length - filled_length)
    
    print(f"\r{prefix} |{bar}| {percent:.1%} {suffix}", end="")
    
    if current == total:
        print()  # 换行

# 使用示例：模拟获取文章的过程
def fetch_articles_with_progress(urls):
    """带进度条的文章获取"""
    articles = []
    total = len(urls)
    
    for i, url in enumerate(urls):
        show_progress(i + 1, total, "获取文章", "完成")
        
        # 模拟网络请求延迟
        time.sleep(0.5)
        
        # 实际的文章获取逻辑
        articles.append(f"文章来自 {url}")
    
    return articles
```

### 3. 分页显示

```python
def paginate_content(content_list, page_size=10):
    """分页显示内容"""
    if not content_list:
        print("📭 无内容显示")
        return
    
    total_pages = (len(content_list) + page_size - 1) // page_size
    current_page = 1
    
    while True:
        start_idx = (current_page - 1) * page_size
        end_idx = start_idx + page_size
        page_content = content_list[start_idx:end_idx]
        
        # 显示当前页内容
        print(f"\n第 {current_page}/{total_pages} 页")
        print("=" * 60)
        
        for i, item in enumerate(page_content, start_idx + 1):
            print(f"[{i}] {item}")
        
        print("=" * 60)
        print("导航: [n]下一页 [p]上一页 [f]首页 [l]末页 [q]退出")
        
        choice = input("请选择: ").strip().lower()
        
        if choice == 'n' and current_page < total_pages:
            current_page += 1
        elif choice == 'p' and current_page > 1:
            current_page -= 1
        elif choice == 'f':
            current_page = 1
        elif choice == 'l':
            current_page = total_pages
        elif choice == 'q':
            break
        else:
            print("❌ 无效选择")

# 使用示例
articles = [f"文章 {i}" for i in range(1, 51)]  # 50 篇文章
paginate_content(articles, page_size=5)
```

## 🔍 搜索和过滤功能

### 1. 简单文本搜索

```python
def search_articles(articles, keyword):
    """在文章中搜索关键词"""
    if not keyword:
        return articles
    
    keyword_lower = keyword.lower()
    matches = []
    
    for article in articles:
        # 在标题和摘要中搜索
        title_match = keyword_lower in article['title'].lower()
        summary_match = keyword_lower in article['summary'].lower()
        
        if title_match or summary_match:
            # 标记匹配部分（简单高亮）
            highlighted_article = article.copy()
            if title_match:
                highlighted_article['title'] = highlight_keyword(
                    article['title'], keyword
                )
            matches.append(highlighted_article)
    
    return matches

def highlight_keyword(text, keyword):
    """高亮关键词"""
    # 简单的高亮实现
    import re
    pattern = re.compile(re.escape(keyword), re.IGNORECASE)
    return pattern.sub(f"**{keyword}**", text)
```

### 2. 高级过滤功能

```python
from datetime import datetime, timedelta
import re

class ArticleFilter:
    """文章过滤器"""
    
    def __init__(self, articles):
        self.articles = articles
    
    def by_keyword(self, keyword):
        """按关键词过滤"""
        if not keyword:
            return self.articles
        
        keyword_lower = keyword.lower()
        return [
            article for article in self.articles
            if keyword_lower in article['title'].lower() or
               keyword_lower in article['summary'].lower()
        ]
    
    def by_date_range(self, start_date=None, end_date=None):
        """按日期范围过滤"""
        filtered = []
        
        for article in self.articles:
            try:
                # 尝试解析日期
                pub_date = datetime.fromisoformat(article['published'])
                
                if start_date and pub_date < start_date:
                    continue
                if end_date and pub_date > end_date:
                    continue
                
                filtered.append(article)
            except (ValueError, KeyError):
                # 日期解析失败，保留文章
                filtered.append(article)
        
        return filtered
    
    def by_source(self, source_pattern):
        """按来源过滤"""
        pattern = re.compile(source_pattern, re.IGNORECASE)
        return [
            article for article in self.articles
            if pattern.search(article.get('source', ''))
        ]
    
    def apply_filters(self, **filters):
        """应用多个过滤器"""
        result = self.articles
        
        if 'keyword' in filters:
            filter_obj = ArticleFilter(result)
            result = filter_obj.by_keyword(filters['keyword'])
        
        if 'start_date' in filters or 'end_date' in filters:
            filter_obj = ArticleFilter(result)
            result = filter_obj.by_date_range(
                filters.get('start_date'),
                filters.get('end_date')
            )
        
        if 'source' in filters:
            filter_obj = ArticleFilter(result)
            result = filter_obj.by_source(filters['source'])
        
        return result

# 交互式搜索界面
def interactive_search(articles):
    """交互式搜索界面"""
    filter_obj = ArticleFilter(articles)
    
    print("🔍 文章搜索和过滤")
    print("输入空值跳过该过滤器")
    
    # 获取搜索条件
    keyword = input("关键词: ").strip()
    
    # 日期过滤
    start_date_str = input("开始日期 (YYYY-MM-DD): ").strip()
    end_date_str = input("结束日期 (YYYY-MM-DD): ").strip()
    
    filters = {}
    if keyword:
        filters['keyword'] = keyword
    
    if start_date_str:
        try:
            filters['start_date'] = datetime.fromisoformat(start_date_str)
        except ValueError:
            print("⚠️  日期格式无效，已忽略")
    
    if end_date_str:
        try:
            filters['end_date'] = datetime.fromisoformat(end_date_str)
        except ValueError:
            print("⚠️  日期格式无效，已忽略")
    
    # 应用过滤器
    filtered_articles = filter_obj.apply_filters(**filters)
    
    print(f"\n🎯 找到 {len(filtered_articles)} 篇匹配的文章:")
    return filtered_articles
```

## 🌍 国际化与本地化

### 1. 基础国际化支持

```python
class I18n:
    """简单的国际化支持类"""
    
    def __init__(self, language='zh'):
        self.language = language
        self.messages = {
            'zh': {
                'welcome': '🎉 欢迎使用 RSS 终端阅读器!',
                'main_menu': '📱 主菜单',
                'add_subscription': '添加订阅源',
                'remove_subscription': '删除订阅源',
                'view_articles': '查看文章',
                'quit': '退出程序',
                'success_added': '✅ 成功添加订阅源: {}',
                'error_network': '❌ 网络请求失败: {}',
                'invalid_choice': '❌ 无效的选择，请重新输入',
                'no_subscriptions': '📭 暂无订阅源，请先添加一些订阅',
            },
            'en': {
                'welcome': '🎉 Welcome to RSS Terminal Reader!',
                'main_menu': '📱 Main Menu',
                'add_subscription': 'Add Subscription',
                'remove_subscription': 'Remove Subscription',
                'view_articles': 'View Articles',
                'quit': 'Exit Program',
                'success_added': '✅ Successfully added subscription: {}',
                'error_network': '❌ Network request failed: {}',
                'invalid_choice': '❌ Invalid choice, please try again',
                'no_subscriptions': '📭 No subscriptions yet, please add some first',
            }
        }
    
    def get(self, key, *args):
        """获取翻译后的文本"""
        message = self.messages.get(self.language, {}).get(key, key)
        if args:
            return message.format(*args)
        return message
    
    def set_language(self, language):
        """设置语言"""
        if language in self.messages:
            self.language = language
            return True
        return False

# 使用国际化的 RSS 阅读器
class InternationalRSSReader:
    def __init__(self, language='zh'):
        self.i18n = I18n(language)
        self.subscriptions = {}
    
    def show_welcome(self):
        print(self.i18n.get('welcome'))
    
    def add_subscription(self, name, url):
        # 添加订阅源逻辑...
        success = True  # 假设成功
        
        if success:
            print(self.i18n.get('success_added', name))
        else:
            print(self.i18n.get('error_network', "Connection failed"))
    
    def change_language(self):
        """语言切换功能"""
        print("\n🌍 Select Language / 选择语言:")
        print("[1] 中文")
        print("[2] English")
        
        choice = input("Choice / 选择: ").strip()
        
        if choice == '1':
            self.i18n.set_language('zh')
            print("✅ 已切换到中文")
        elif choice == '2':
            self.i18n.set_language('en')
            print("✅ Language switched to English")
        else:
            print("❌ Invalid choice / 无效选择")
```

### 2. 时间和日期本地化

```python
from datetime import datetime
import locale

class DateFormatter:
    """日期格式化工具"""
    
    def __init__(self, language='zh'):
        self.language = language
        self.setup_locale()
    
    def setup_locale(self):
        """设置本地化环境"""
        try:
            if self.language == 'zh':
                locale.setlocale(locale.LC_TIME, 'zh_CN.UTF-8')
            elif self.language == 'en':
                locale.setlocale(locale.LC_TIME, 'en_US.UTF-8')
        except locale.Error:
            # 如果系统不支持该本地化设置，使用默认设置
            pass
    
    def format_datetime(self, dt_string):
        """格式化日期时间"""
        try:
            dt = datetime.fromisoformat(dt_string.replace('Z', '+00:00'))
            
            if self.language == 'zh':
                return dt.strftime('%Y年%m月%d日 %H:%M:%S')
            else:
                return dt.strftime('%B %d, %Y %H:%M:%S')
        
        except (ValueError, AttributeError):
            return dt_string  # 返回原始字符串
    
    def format_relative_time(self, dt_string):
        """格式化相对时间（如"2小时前"）"""
        try:
            dt = datetime.fromisoformat(dt_string.replace('Z', '+00:00'))
            now = datetime.now()
            diff = now - dt
            
            if diff.days > 0:
                if self.language == 'zh':
                    return f"{diff.days} 天前"
                else:
                    return f"{diff.days} days ago"
            elif diff.seconds > 3600:
                hours = diff.seconds // 3600
                if self.language == 'zh':
                    return f"{hours} 小时前"
                else:
                    return f"{hours} hours ago"
            elif diff.seconds > 60:
                minutes = diff.seconds // 60
                if self.language == 'zh':
                    return f"{minutes} 分钟前"
                else:
                    return f"{minutes} minutes ago"
            else:
                if self.language == 'zh':
                    return "刚刚"
                else:
                    return "just now"
        
        except (ValueError, AttributeError):
            return dt_string
```

## 🎯 学习检查点

完成本章学习后，你应该能够：

### ✅ 基础概念检查
- [ ] 理解CLI设计的基本原则
- [ ] 掌握用户输入的获取和验证技术
- [ ] 能够设计直观的菜单系统
- [ ] 熟练使用各种输出格式化技术
- [ ] 了解国际化和本地化的实现方法
- [ ] 掌握搜索和过滤功能的设计
- [ ] 能够实现分页显示和进度提示

### 🧪 实践练习建议

1. **改进RSS项目的用户界面**：
   - 添加颜色输出支持
   - 实现表格式的订阅源列表显示
   - 添加进度条显示文章获取过程

2. **增强输入验证**：
   - 实现更强大的URL验证
   - 添加邮箱地址验证
   - 实现自定义验证规则

3. **设计高级菜单系统**：
   - 创建可配置的菜单系统
   - 实现快捷键支持
   - 添加菜单历史记录功能

4. **实现搜索功能**：
   - 为RSS项目添加文章搜索功能
   - 实现多条件过滤
   - 添加搜索结果高亮显示

5. **添加国际化支持**：
   - 为RSS项目添加多语言支持
   - 实现语言切换功能
   - 本地化日期和时间显示

## 🚀 下一步

现在你已经掌握了用户交互与界面设计的核心技术，接下来将学习**FAQ常见问题解答**，了解实际开发和使用中可能遇到的问题和解决方案。

请继续阅读：`08_FAQ常见问题解答.md`

---

*优秀的用户界面设计是软件成功的关键因素之一，用户体验决定了软件的可用性和受欢迎程度！* 🎨💻
