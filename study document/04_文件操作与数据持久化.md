# 文件操作与数据持久化

## 🎯 学习目标
通过分析RSS阅读器的数据存储机制，深入理解Python文件操作、JSON处理和数据持久化的最佳实践。

## 📚 目录
1. [文件操作基础](#文件操作基础)
2. [JSON数据处理](#json数据处理)
3. [异常处理与错误恢复](#异常处理与错误恢复)
4. [文件路径管理](#文件路径管理)
5. [数据持久化策略](#数据持久化策略)
6. [配置文件最佳实践](#配置文件最佳实践)

---

## 文件操作基础

### 1.1 文件读取操作详解

让我们分析RSS阅读器中的文件读取代码：

```python
def load_subscriptions(self):
    """从本地文件加载订阅源"""
    if os.path.exists(self.config_file):
        try:
            with open(self.config_file, 'r', encoding='utf-8') as f:
                self.subscriptions = json.load(f)
            print(f"✅ 已加载 {len(self.subscriptions)} 个订阅源")
        except (json.JSONDecodeError, FileNotFoundError) as e:
            print(f"⚠️  配置文件读取错误: {e}")
            self.subscriptions = {}
    else:
        print("🆕 首次使用，将创建新的订阅配置")
        self.subscriptions = {}
```

**文件操作关键概念：**

#### with语句（上下文管理器）
```python
with open(self.config_file, 'r', encoding='utf-8') as f:
    # 文件操作
    pass
# 文件自动关闭，即使发生异常也会正确关闭
```

**深入理解with语句：**
- **自动资源管理**：确保文件在使用后被正确关闭
- **异常安全**：即使代码抛出异常，文件也会被关闭
- **等价的传统写法**：
```python
# 不推荐的写法
f = open(self.config_file, 'r', encoding='utf-8')
try:
    data = json.load(f)
finally:
    f.close()  # 必须手动关闭

# 推荐的写法
with open(self.config_file, 'r', encoding='utf-8') as f:
    data = json.load(f)  # 自动关闭
```

#### 文件打开模式详解

```python
# 常用文件模式
'r'     # 只读模式（默认）
'w'     # 写入模式（覆盖原文件）
'a'     # 追加模式
'r+'    # 读写模式
'w+'    # 读写模式（覆盖）
'a+'    # 读写模式（追加）

# 二进制模式
'rb'    # 二进制只读
'wb'    # 二进制写入

# 文本模式参数
encoding='utf-8'    # 指定编码
newline=''          # 换行符处理
```

#### 编码处理的重要性

```python
# ✅ 正确：明确指定编码
with open(filename, 'r', encoding='utf-8') as f:
    content = f.read()

# ❌ 错误：使用系统默认编码（可能导致乱码）
with open(filename, 'r') as f:
    content = f.read()
```

**编码问题案例：**
```python
# 在Windows上可能默认为gbk编码
# 在macOS/Linux上可能默认为utf-8编码
# 不同系统间文件交换可能出现乱码

# 最佳实践：总是明确指定编码
def safe_read_file(filename: str) -> str:
    """安全读取文件，处理编码问题"""
    encodings = ['utf-8', 'gbk', 'latin-1']
    
    for encoding in encodings:
        try:
            with open(filename, 'r', encoding=encoding) as f:
                return f.read()
        except UnicodeDecodeError:
            continue
    
    raise ValueError(f"无法用常见编码读取文件: {filename}")
```

### 1.2 文件写入操作分析

```python
def save_subscriptions(self):
    """保存订阅源到本地文件"""
    try:
        with open(self.config_file, 'w', encoding='utf-8') as f:
            json.dump(self.subscriptions, f, ensure_ascii=False, indent=2)
        print("💾 订阅源已保存")
    except Exception as e:
        print(f"❌ 保存失败: {e}")
```

**写入操作要点：**

#### 文件写入的原子性问题
```python
# 当前实现的问题：直接覆盖原文件
# 如果写入过程中断，原文件可能被损坏

# 改进的原子写入
def atomic_save_subscriptions(self):
    """原子性保存订阅源"""
    import tempfile
    import shutil
    
    # 1. 写入临时文件
    temp_file = self.config_file + '.tmp'
    try:
        with open(temp_file, 'w', encoding='utf-8') as f:
            json.dump(self.subscriptions, f, ensure_ascii=False, indent=2)
        
        # 2. 原子性替换（大多数操作系统保证这是原子操作）
        shutil.move(temp_file, self.config_file)
        print("💾 订阅源已保存")
        
    except Exception as e:
        # 3. 清理临时文件
        if os.path.exists(temp_file):
            os.remove(temp_file)
        print(f"❌ 保存失败: {e}")
        raise
```

#### 备份策略
```python
def save_with_backup(self):
    """保存时创建备份"""
    # 1. 创建备份
    if os.path.exists(self.config_file):
        backup_file = self.config_file + '.bak'
        shutil.copy2(self.config_file, backup_file)
    
    # 2. 保存新数据
    try:
        with open(self.config_file, 'w', encoding='utf-8') as f:
            json.dump(self.subscriptions, f, ensure_ascii=False, indent=2)
        print("💾 订阅源已保存")
    except Exception as e:
        # 3. 恢复备份
        backup_file = self.config_file + '.bak'
        if os.path.exists(backup_file):
            shutil.copy2(backup_file, self.config_file)
            print("🔄 已从备份恢复")
        raise
```

---

## JSON数据处理

### 2.1 JSON序列化深入分析

```python
json.dump(self.subscriptions, f, ensure_ascii=False, indent=2)
```

**JSON参数详解：**

#### ensure_ascii参数
```python
# ensure_ascii=False：允许非ASCII字符（中文正常显示）
{"新闻": "http://example.com"}

# ensure_ascii=True（默认）：转义非ASCII字符
{"\u65b0\u95fb": "http://example.com"}
```

#### indent参数
```python
# indent=2：格式化输出，每层缩进2个空格
{
  "新闻": "http://news.example.com",
  "科技": "http://tech.example.com"
}

# indent=None（默认）：紧凑输出
{"新闻":"http://news.example.com","科技":"http://tech.example.com"}
```

#### 其他重要参数
```python
json.dump(data, f,
    ensure_ascii=False,    # 支持中文
    indent=2,              # 格式化输出
    sort_keys=True,        # 键排序
    separators=(',', ': ') # 自定义分隔符
)
```

### 2.2 JSON反序列化与验证

```python
def load_subscriptions_with_validation(self):
    """加载并验证订阅源数据"""
    if not os.path.exists(self.config_file):
        print("🆕 首次使用，将创建新的订阅配置")
        self.subscriptions = {}
        return
    
    try:
        with open(self.config_file, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        # 验证数据结构
        if not isinstance(data, dict):
            raise ValueError("配置文件格式错误：根元素必须是字典")
        
        # 验证每个条目
        validated_data = {}
        for name, url in data.items():
            if isinstance(name, str) and isinstance(url, str):
                validated_data[name] = url
            else:
                print(f"⚠️  跳过无效条目: {name} -> {url}")
        
        self.subscriptions = validated_data
        print(f"✅ 已加载 {len(self.subscriptions)} 个订阅源")
        
    except json.JSONDecodeError as e:
        print(f"❌ JSON格式错误: {e}")
        self._handle_corrupted_config()
    except (FileNotFoundError, PermissionError) as e:
        print(f"❌ 文件访问错误: {e}")
        self.subscriptions = {}
    except Exception as e:
        print(f"❌ 未知错误: {e}")
        self._handle_corrupted_config()

def _handle_corrupted_config(self):
    """处理损坏的配置文件"""
    # 1. 尝试从备份恢复
    backup_file = self.config_file + '.bak'
    if os.path.exists(backup_file):
        try:
            shutil.copy2(backup_file, self.config_file)
            print("🔄 从备份文件恢复配置")
            self.load_subscriptions_with_validation()
            return
        except Exception:
            pass
    
    # 2. 重命名损坏的文件
    corrupted_file = self.config_file + '.corrupted'
    try:
        shutil.move(self.config_file, corrupted_file)
        print(f"🗃️  损坏的配置已移动到: {corrupted_file}")
    except Exception:
        pass
    
    # 3. 重新初始化
    self.subscriptions = {}
    print("🆕 重新创建配置文件")
```

### 2.3 复杂数据结构的处理

如果我们要存储更复杂的订阅信息：

```python
# 扩展的数据结构
subscription_data = {
    "subscriptions": {
        "新闻": {
            "url": "http://news.example.com/rss",
            "category": "news",
            "added_date": "2025-01-01",
            "last_updated": "2025-01-10",
            "update_frequency": 3600,  # 秒
            "enabled": True
        }
    },
    "settings": {
        "default_article_limit": 5,
        "auto_refresh": True,
        "theme": "dark"
    }
}

# 序列化时的类型处理
import datetime

def json_serializer(obj):
    """自定义JSON序列化器"""
    if isinstance(obj, datetime.datetime):
        return obj.isoformat()
    elif isinstance(obj, datetime.date):
        return obj.isoformat()
    elif hasattr(obj, '__dict__'):
        return obj.__dict__
    raise TypeError(f"Object of type {type(obj)} is not JSON serializable")

# 使用自定义序列化器
with open(filename, 'w') as f:
    json.dump(data, f, default=json_serializer, indent=2)
```

---

## 异常处理与错误恢复

### 3.1 异常层次结构

```python
try:
    with open(self.config_file, 'r', encoding='utf-8') as f:
        self.subscriptions = json.load(f)
except (json.JSONDecodeError, FileNotFoundError) as e:
    print(f"⚠️  配置文件读取错误: {e}")
    self.subscriptions = {}
```

**异常处理策略分析：**

#### 具体异常类型的选择
```python
# 文件相关异常
FileNotFoundError      # 文件不存在
PermissionError        # 权限不足
IsADirectoryError      # 路径是目录而非文件
OSError               # 其他OS级别错误

# JSON相关异常
json.JSONDecodeError   # JSON格式错误

# 通用异常
ValueError            # 值错误
TypeError             # 类型错误
Exception             # 通用异常基类
```

#### 异常处理的层次结构
```python
def robust_load_subscriptions(self):
    """健壮的订阅源加载"""
    try:
        self._load_from_file()
    except FileNotFoundError:
        print("📂 配置文件不存在，创建新配置")
        self._create_default_config()
    except PermissionError:
        print("🔒 文件权限不足，请检查文件权限")
        self._prompt_permission_fix()
    except json.JSONDecodeError as e:
        print(f"📄 JSON格式错误: {e}")
        self._handle_json_error(e)
    except UnicodeDecodeError as e:
        print(f"🔤 编码错误: {e}")
        self._handle_encoding_error()
    except OSError as e:
        print(f"💾 系统错误: {e}")
        self._handle_system_error(e)
    except Exception as e:
        print(f"❓ 未知错误: {e}")
        self._handle_unknown_error(e)

def _load_from_file(self):
    """从文件加载数据"""
    with open(self.config_file, 'r', encoding='utf-8') as f:
        data = json.load(f)
        self._validate_and_set_data(data)

def _validate_and_set_data(self, data):
    """验证并设置数据"""
    if not isinstance(data, dict):
        raise ValueError("数据必须是字典格式")
    
    # 进一步验证...
    self.subscriptions = data
```

### 3.2 错误恢复策略

```python
class RecoverableRSSReader:
    def __init__(self):
        self.config_file = "rss_subscriptions.json"
        self.backup_file = self.config_file + ".bak"
        self.subscriptions = {}
        self._load_with_recovery()
    
    def _load_with_recovery(self):
        """多级恢复策略"""
        # 1. 尝试加载主配置文件
        if self._try_load_main_config():
            return
        
        # 2. 尝试从备份恢复
        if self._try_load_backup():
            print("🔄 从备份文件恢复成功")
            return
        
        # 3. 尝试从损坏文件中提取有效数据
        if self._try_extract_valid_data():
            print("🛠️  从损坏文件中提取了部分有效数据")
            return
        
        # 4. 创建新配置
        print("🆕 创建新的配置文件")
        self.subscriptions = {}
        self._save_default_config()
    
    def _try_load_main_config(self) -> bool:
        """尝试加载主配置文件"""
        try:
            with open(self.config_file, 'r', encoding='utf-8') as f:
                self.subscriptions = json.load(f)
            return True
        except (FileNotFoundError, json.JSONDecodeError, OSError):
            return False
    
    def _try_load_backup(self) -> bool:
        """尝试从备份文件恢复"""
        if not os.path.exists(self.backup_file):
            return False
        
        try:
            with open(self.backup_file, 'r', encoding='utf-8') as f:
                self.subscriptions = json.load(f)
            # 恢复成功后，重新创建主文件
            self.save_subscriptions()
            return True
        except (json.JSONDecodeError, OSError):
            return False
    
    def _try_extract_valid_data(self) -> bool:
        """从损坏的文件中提取有效数据"""
        try:
            with open(self.config_file, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # 尝试修复常见的JSON错误
            content = self._fix_common_json_errors(content)
            data = json.loads(content)
            
            # 提取有效的订阅数据
            valid_subscriptions = {}
            if isinstance(data, dict):
                for name, url in data.items():
                    if isinstance(name, str) and isinstance(url, str):
                        valid_subscriptions[name] = url
            
            if valid_subscriptions:
                self.subscriptions = valid_subscriptions
                return True
            
        except Exception:
            pass
        
        return False
    
    def _fix_common_json_errors(self, content: str) -> str:
        """修复常见的JSON错误"""
        # 移除末尾的逗号
        content = re.sub(r',(\s*[}\]])', r'\1', content)
        
        # 修复单引号（JSON只支持双引号）
        content = content.replace("'", '"')
        
        # 其他常见修复...
        return content
```

---

## 文件路径管理

### 4.1 路径处理最佳实践

当前代码使用相对路径：
```python
self.config_file = "rss_subscriptions.json"
```

**改进的路径管理：**

```python
import os
from pathlib import Path

class PathManagedRSSReader:
    def __init__(self, config_dir: str = None):
        # 使用pathlib进行路径管理
        if config_dir:
            self.config_dir = Path(config_dir)
        else:
            # 默认使用用户配置目录
            self.config_dir = self._get_default_config_dir()
        
        # 确保配置目录存在
        self.config_dir.mkdir(parents=True, exist_ok=True)
        
        # 配置文件路径
        self.config_file = self.config_dir / "rss_subscriptions.json"
        self.backup_file = self.config_dir / "rss_subscriptions.json.bak"
        
        self.subscriptions = {}
        self.load_subscriptions()
    
    def _get_default_config_dir(self) -> Path:
        """获取默认配置目录"""
        if os.name == 'nt':  # Windows
            base = os.environ.get('APPDATA', os.path.expanduser('~'))
        else:  # macOS/Linux
            base = os.environ.get('XDG_CONFIG_HOME', os.path.expanduser('~/.config'))
        
        return Path(base) / "rss-reader"
    
    def load_subscriptions(self):
        """使用Path对象进行文件操作"""
        if self.config_file.exists():
            try:
                with self.config_file.open('r', encoding='utf-8') as f:
                    self.subscriptions = json.load(f)
                print(f"✅ 已加载 {len(self.subscriptions)} 个订阅源")
            except (json.JSONDecodeError, OSError) as e:
                print(f"⚠️  配置文件读取错误: {e}")
                self.subscriptions = {}
        else:
            print("🆕 首次使用，将创建新的订阅配置")
            self.subscriptions = {}
```

#### pathlib的优势

```python
from pathlib import Path

# 传统的os.path方式
config_dir = os.path.join(os.path.expanduser('~'), '.config', 'rss-reader')
config_file = os.path.join(config_dir, 'subscriptions.json')
if not os.path.exists(config_dir):
    os.makedirs(config_dir)

# pathlib方式（更清晰）
config_dir = Path.home() / '.config' / 'rss-reader'
config_file = config_dir / 'subscriptions.json'
config_dir.mkdir(parents=True, exist_ok=True)

# pathlib的方法链调用
config_file.parent.mkdir(parents=True, exist_ok=True)
if config_file.exists():
    content = config_file.read_text(encoding='utf-8')
```

### 4.2 跨平台路径处理

```python
class CrossPlatformRSSReader:
    def __init__(self):
        self.app_name = "RSS Reader"
        self.config_file = self._get_config_file_path()
    
    def _get_config_file_path(self) -> Path:
        """获取跨平台的配置文件路径"""
        import platform
        
        system = platform.system()
        
        if system == "Windows":
            # Windows: %APPDATA%/RSS Reader/config.json
            base_dir = Path(os.environ.get('APPDATA', Path.home() / 'AppData' / 'Roaming'))
        elif system == "Darwin":  # macOS
            # macOS: ~/Library/Application Support/RSS Reader/config.json
            base_dir = Path.home() / 'Library' / 'Application Support'
        else:  # Linux and others
            # Linux: ~/.config/rss-reader/config.json
            base_dir = Path(os.environ.get('XDG_CONFIG_HOME', Path.home() / '.config'))
            # Linux中使用小写和连字符
            self.app_name = "rss-reader"
        
        config_dir = base_dir / self.app_name
        config_dir.mkdir(parents=True, exist_ok=True)
        
        return config_dir / "config.json"
```

---

## 数据持久化策略

### 5.1 数据版本管理

```python
class VersionedRSSReader:
    CURRENT_VERSION = "1.1"
    
    def save_subscriptions(self):
        """保存带版本信息的数据"""
        data = {
            "version": self.CURRENT_VERSION,
            "timestamp": datetime.now().isoformat(),
            "subscriptions": self.subscriptions,
            "metadata": {
                "total_subscriptions": len(self.subscriptions),
                "created_by": "RSS Reader v1.1"
            }
        }
        
        try:
            with open(self.config_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
            print("💾 订阅源已保存")
        except Exception as e:
            print(f"❌ 保存失败: {e}")
    
    def load_subscriptions(self):
        """加载并处理版本兼容性"""
        if not os.path.exists(self.config_file):
            self.subscriptions = {}
            return
        
        try:
            with open(self.config_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            # 处理不同版本的数据格式
            if isinstance(data, dict) and "version" in data:
                # 新格式（带版本信息）
                self._load_versioned_data(data)
            else:
                # 旧格式（直接是订阅数据）
                self._load_legacy_data(data)
                
        except Exception as e:
            print(f"❌ 加载失败: {e}")
            self.subscriptions = {}
    
    def _load_versioned_data(self, data: dict):
        """加载带版本信息的数据"""
        version = data.get("version", "1.0")
        
        if version == "1.0":
            self.subscriptions = data.get("subscriptions", {})
        elif version == "1.1":
            self.subscriptions = data.get("subscriptions", {})
            # 处理1.1版本的新功能
        else:
            print(f"⚠️  未知版本: {version}，尝试兼容加载")
            self.subscriptions = data.get("subscriptions", {})
    
    def _load_legacy_data(self, data):
        """加载旧格式数据并升级"""
        if isinstance(data, dict):
            self.subscriptions = data
            print("🔄 检测到旧格式数据，已自动升级")
            self.save_subscriptions()  # 保存为新格式
        else:
            self.subscriptions = {}
```

### 5.2 数据压缩与优化

对于大量数据的情况：

```python
import gzip
import pickle

class OptimizedRSSReader:
    def __init__(self):
        self.config_file = "rss_subscriptions.json.gz"
        self.subscriptions = {}
    
    def save_compressed(self):
        """保存压缩数据"""
        data = {
            "subscriptions": self.subscriptions,
            "timestamp": datetime.now().isoformat()
        }
        
        # 方法1: 压缩JSON
        json_str = json.dumps(data, ensure_ascii=False)
        with gzip.open(self.config_file, 'wt', encoding='utf-8') as f:
            f.write(json_str)
        
        # 方法2: 使用pickle（二进制，更高效但不可读）
        # with gzip.open(self.config_file.replace('.json.gz', '.pkl.gz'), 'wb') as f:
        #     pickle.dump(data, f)
    
    def load_compressed(self):
        """加载压缩数据"""
        try:
            with gzip.open(self.config_file, 'rt', encoding='utf-8') as f:
                data = json.load(f)
            self.subscriptions = data.get("subscriptions", {})
        except (FileNotFoundError, json.JSONDecodeError, OSError):
            self.subscriptions = {}
```

---

## 配置文件最佳实践

### 6.1 配置文件结构设计

```python
# 推荐的配置文件结构
{
  "version": "1.1",
  "metadata": {
    "created": "2025-01-01T10:00:00",
    "last_modified": "2025-01-10T15:30:00",
    "total_subscriptions": 5
  },
  "settings": {
    "default_article_limit": 5,
    "auto_refresh_interval": 3600,
    "theme": "default",
    "language": "zh-CN"
  },
  "subscriptions": {
    "新闻": {
      "url": "http://news.example.com/rss",
      "category": "news",
      "enabled": true,
      "last_updated": "2025-01-10T15:00:00",
      "article_count": 0
    }
  }
}
```

### 6.2 配置验证与迁移

```python
class ConfigManager:
    def __init__(self, config_file: str):
        self.config_file = Path(config_file)
        self.schema_version = "1.1"
        self.config = self._load_and_validate()
    
    def _load_and_validate(self) -> dict:
        """加载并验证配置"""
        if not self.config_file.exists():
            return self._create_default_config()
        
        try:
            with self.config_file.open('r', encoding='utf-8') as f:
                config = json.load(f)
            
            # 验证配置结构
            validated_config = self._validate_config(config)
            
            # 检查是否需要迁移
            if self._needs_migration(validated_config):
                validated_config = self._migrate_config(validated_config)
            
            return validated_config
            
        except Exception as e:
            print(f"❌ 配置加载失败: {e}")
            return self._create_default_config()
    
    def _validate_config(self, config: dict) -> dict:
        """验证配置格式"""
        required_keys = ["version", "settings", "subscriptions"]
        
        for key in required_keys:
            if key not in config:
                raise ValueError(f"缺少必需的配置项: {key}")
        
        # 验证订阅数据
        if not isinstance(config["subscriptions"], dict):
            config["subscriptions"] = {}
        
        # 验证设置数据
        if not isinstance(config["settings"], dict):
            config["settings"] = self._get_default_settings()
        
        return config
    
    def _needs_migration(self, config: dict) -> bool:
        """检查是否需要迁移"""
        config_version = config.get("version", "1.0")
        return config_version != self.schema_version
    
    def _migrate_config(self, config: dict) -> dict:
        """迁移配置到新版本"""
        config_version = config.get("version", "1.0")
        
        if config_version == "1.0":
            config = self._migrate_from_v1_0(config)
        
        config["version"] = self.schema_version
        self._save_config(config)
        print(f"🔄 配置已从 v{config_version} 迁移到 v{self.schema_version}")
        
        return config
    
    def _migrate_from_v1_0(self, config: dict) -> dict:
        """从1.0版本迁移"""
        # 添加新的设置项
        if "settings" not in config:
            config["settings"] = self._get_default_settings()
        
        # 转换订阅格式
        if "subscriptions" in config:
            old_subscriptions = config["subscriptions"]
            new_subscriptions = {}
            
            for name, url in old_subscriptions.items():
                new_subscriptions[name] = {
                    "url": url,
                    "category": "general",
                    "enabled": True,
                    "added_date": datetime.now().isoformat()
                }
            
            config["subscriptions"] = new_subscriptions
        
        return config
```

---

## 🎯 实践练习

### 练习1：实现安全的文件操作
编写一个支持原子写入和备份的配置管理器：

```python
class SafeConfigManager:
    def __init__(self, config_file: str):
        self.config_file = Path(config_file)
        self.backup_file = self.config_file.with_suffix('.json.bak')
    
    def save_config(self, data: dict) -> bool:
        """原子性保存配置，支持备份"""
        # 你的实现
        pass
    
    def load_config(self) -> dict:
        """加载配置，支持从备份恢复"""
        # 你的实现
        pass
```

### 练习2：实现配置文件加密
为敏感配置添加加密功能：

```python
import base64
from cryptography.fernet import Fernet

class EncryptedConfigManager:
    def __init__(self, config_file: str, password: str):
        self.config_file = config_file
        self.cipher = self._create_cipher(password)
    
    def _create_cipher(self, password: str):
        """从密码创建加密器"""
        # 你的实现
        pass
    
    def save_encrypted(self, data: dict):
        """保存加密的配置"""
        # 你的实现
        pass
    
    def load_encrypted(self) -> dict:
        """加载并解密配置"""
        # 你的实现
        pass
```

### 练习3：实现多格式支持
支持JSON、YAML、TOML等多种配置格式：

```python
class MultiFormatConfig:
    def __init__(self, config_file: str):
        self.config_file = Path(config_file)
        self.format = self._detect_format()
    
    def _detect_format(self) -> str:
        """根据文件扩展名检测格式"""
        # 你的实现
        pass
    
    def save(self, data: dict):
        """根据格式保存数据"""
        # 你的实现
        pass
    
    def load(self) -> dict:
        """根据格式加载数据"""
        # 你的实现
        pass
```

---

## 📖 扩展阅读

1. **Python文件I/O官方文档**：https://docs.python.org/3/tutorial/inputoutput.html
2. **JSON模块文档**：https://docs.python.org/3/library/json.html
3. **pathlib模块指南**：https://docs.python.org/3/library/pathlib.html
4. **配置文件最佳实践**：12-Factor App配置原则

---

## 🔗 下一章预告

下一章我们将学习**网络编程与HTTP请求**，包括：
- requests库的深入使用
- HTTP协议基础
- 网络异常处理
- RSS Feed解析技巧

深入网络编程的世界！🌐
