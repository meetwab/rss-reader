# 错误处理与异常管理详解

## 🚨 异常处理基础概念

### 什么是异常？
异常是程序运行时遇到的错误情况。Python使用异常机制来处理错误，让程序能够优雅地处理意外情况。

```python
# 常见异常类型
FileNotFoundError    # 文件不存在
ValueError          # 值错误
TypeError           # 类型错误
KeyError           # 字典键不存在
IndexError         # 列表索引超出范围
ConnectionError    # 网络连接错误
TimeoutError       # 超时错误
```

### 异常处理的重要性
1. **程序稳定性**：防止程序崩溃
2. **用户体验**：提供友好的错误信息
3. **调试便利**：帮助开发者定位问题
4. **资源管理**：确保资源正确释放

## 📖 try-except基础语法

### 基本结构
```python
try:
    # 可能出错的代码
    result = risky_operation()
except ExceptionType:
    # 处理特定异常
    handle_error()
```

### 完整语法
```python
try:
    # 尝试执行的代码
    risky_code()
except SpecificError as e:
    # 处理特定异常
    print(f"特定错误: {e}")
except (Error1, Error2) as e:
    # 处理多种异常
    print(f"多种错误之一: {e}")
except Exception as e:
    # 处理所有其他异常
    print(f"未预期的错误: {e}")
else:
    # 没有异常时执行
    print("执行成功")
finally:
    # 无论是否有异常都执行
    cleanup_resources()
```

## 🔍 RSS阅读器中的异常处理分析

### 1. 网络请求异常处理

```python
def add_subscription(self, name: str, url: str) -> bool:
    """添加新的订阅源"""
    try:
        # 验证 RSS 链接是否有效
        print(f"🔍 正在验证 RSS 链接: {url}")
        response = requests.get(url, timeout=10)
        response.raise_for_status()
        
        # ... 其他逻辑
        
    except requests.exceptions.RequestException as e:
        print(f"❌ 网络请求失败: {e}")
        return False
    except Exception as e:
        print(f"❌ 添加订阅源失败: {e}")
        return False
```

**分析关键点：**

#### requests异常层次结构
```python
requests.exceptions.RequestException
├── requests.exceptions.ConnectionError
├── requests.exceptions.HTTPError
├── requests.exceptions.Timeout
├── requests.exceptions.TooManyRedirects
└── requests.exceptions.URLRequired
```

#### 更精确的异常处理
```python
def robust_http_request(url: str, timeout: int = 10) -> Optional[requests.Response]:
    """健壮的HTTP请求函数"""
    try:
        response = requests.get(url, timeout=timeout)
        response.raise_for_status()
        return response
        
    except requests.exceptions.Timeout:
        print(f"⏰ 请求超时: {url}")
        print("建议：检查网络连接或增加超时时间")
        
    except requests.exceptions.ConnectionError:
        print(f"🔌 连接失败: {url}")
        print("建议：检查网络连接或URL是否正确")
        
    except requests.exceptions.HTTPError as e:
        status_code = e.response.status_code
        if status_code == 404:
            print(f"📄 资源不存在 (404): {url}")
        elif status_code == 403:
            print(f"🚫 访问被拒绝 (403): {url}")
        elif status_code >= 500:
            print(f"🔧 服务器错误 ({status_code}): {url}")
        else:
            print(f"❌ HTTP错误 ({status_code}): {e}")
            
    except requests.exceptions.RequestException as e:
        print(f"❌ 请求异常: {e}")
        
    return None
```

### 2. 文件操作异常处理

```python
def load_subscriptions(self):
    """从本地文件加载订阅源"""
    if os.path.exists(self.config_file):
        try:
            with open(self.config_file, 'r', encoding='utf-8') as f:
                self.subscriptions = json.load(f)
            print(f"✅ 已加载 {len(self.subscriptions)} 个订阅源")
        except (json.JSONDecodeError, FileNotFoundError) as e:
            print(f"⚠️  配置文件读取错误: {e}")
            self.subscriptions = {}
    else:
        print("🆕 首次使用，将创建新的订阅配置")
        self.subscriptions = {}
```

#### 改进的文件操作异常处理
```python
def load_subscriptions_enhanced(self):
    """增强版配置加载"""
    try:
        if not os.path.exists(self.config_file):
            print("🆕 首次使用，将创建新的订阅配置")
            self.subscriptions = {}
            return
        
        with open(self.config_file, 'r', encoding='utf-8') as f:
            content = f.read()
            
        if not content.strip():
            print("⚠️  配置文件为空，初始化新配置")
            self.subscriptions = {}
            return
            
        self.subscriptions = json.loads(content)
        print(f"✅ 已加载 {len(self.subscriptions)} 个订阅源")
        
    except json.JSONDecodeError as e:
        print(f"❌ JSON格式错误: {e}")
        print(f"错误位置: 行 {e.lineno}, 列 {e.colno}")
        
        # 备份损坏的文件
        backup_file = f"{self.config_file}.backup"
        try:
            os.rename(self.config_file, backup_file)
            print(f"📋 已备份损坏文件到: {backup_file}")
        except OSError:
            pass
            
        self.subscriptions = {}
        
    except FileNotFoundError:
        print("❌ 配置文件不存在")
        self.subscriptions = {}
        
    except PermissionError:
        print("❌ 没有权限读取配置文件")
        self.subscriptions = {}
        
    except UnicodeDecodeError as e:
        print(f"❌ 文件编码错误: {e}")
        print("建议：确保文件使用UTF-8编码")
        self.subscriptions = {}
        
    except Exception as e:
        print(f"❌ 未预期的错误: {e}")
        self.subscriptions = {}
```

### 3. RSS解析异常处理

```python
def fetch_articles_safe(self, url: str, limit: int = 5) -> List[Dict]:
    """安全的文章获取函数"""
    try:
        # 网络请求
        response = self.robust_http_request(url)
        if not response:
            return []
        
        # RSS解析
        feed = feedparser.parse(response.content)
        
        # 检查解析质量
        if feed.bozo:
            print(f"⚠️  RSS解析警告: {feed.bozo_exception}")
            # 但仍然尝试处理可用数据
        
        if not feed.entries:
            print("📭 RSS源中没有找到文章")
            return []
        
        articles = []
        for entry in feed.entries[:limit]:
            try:
                article = self.parse_single_entry(entry)
                if article:  # 只添加成功解析的文章
                    articles.append(article)
            except Exception as e:
                print(f"⚠️  跳过有问题的文章: {e}")
                continue
        
        return articles
        
    except Exception as e:
        print(f"❌ 获取文章失败: {e}")
        return []

def parse_single_entry(self, entry) -> Optional[Dict]:
    """解析单个RSS条目"""
    try:
        # 安全地提取字段
        title = self.safe_get_field(entry, ['title'], '无标题')
        link = self.safe_get_field(entry, ['link'], '')
        summary = self.safe_get_field(
            entry, 
            ['summary', 'description', 'content'], 
            '无摘要'
        )
        published = self.safe_get_field(
            entry, 
            ['published', 'updated'], 
            '未知日期'
        )
        
        return {
            'title': self.clean_text(title),
            'link': link,
            'summary': self.clean_text(summary)[:200] + "...",
            'published': published
        }
        
    except Exception as e:
        print(f"❌ 解析条目失败: {e}")
        return None

def safe_get_field(self, entry, field_names: List[str], default: str) -> str:
    """安全地获取RSS条目字段"""
    for field_name in field_names:
        if hasattr(entry, field_name):
            value = getattr(entry, field_name)
            if value:
                return str(value)
    return default
```

## 🛡️ 异常处理最佳实践

### 1. 异常处理层次化

```python
class RSSReaderError(Exception):
    """RSS阅读器基础异常"""
    pass

class NetworkError(RSSReaderError):
    """网络相关异常"""
    pass

class ParseError(RSSReaderError):
    """解析相关异常"""
    pass

class ConfigError(RSSReaderError):
    """配置相关异常"""
    pass

# 使用自定义异常
def validate_rss_url(url: str) -> bool:
    """验证RSS URL"""
    if not url:
        raise ValueError("URL不能为空")
    
    if not url.startswith(('http://', 'https://')):
        raise ValueError("URL必须以http://或https://开头")
    
    try:
        response = requests.get(url, timeout=5)
        response.raise_for_status()
    except requests.exceptions.RequestException as e:
        raise NetworkError(f"网络请求失败: {e}")
    
    try:
        feed = feedparser.parse(response.content)
        if not feed.entries:
            raise ParseError("RSS源中没有找到文章")
    except Exception as e:
        raise ParseError(f"RSS解析失败: {e}")
    
    return True
```

### 2. 优雅的错误恢复

```python
class ResilientRSSReader:
    """具有容错能力的RSS阅读器"""
    
    def __init__(self):
        self.config_file = "rss_subscriptions.json"
        self.backup_file = "rss_subscriptions.backup.json"
        self.subscriptions = {}
        self.error_log = []
        self.load_subscriptions_with_recovery()
    
    def load_subscriptions_with_recovery(self):
        """带恢复机制的配置加载"""
        
        # 尝试加载主配置文件
        if self.try_load_config(self.config_file):
            return
        
        print("⚠️  主配置文件损坏，尝试从备份恢复...")
        
        # 尝试加载备份文件
        if self.try_load_config(self.backup_file):
            print("✅ 从备份文件恢复成功")
            self.save_subscriptions()  # 重新保存主文件
            return
        
        # 创建新配置
        print("🆕 创建全新配置")
        self.subscriptions = {}
        self.save_subscriptions()
    
    def try_load_config(self, filename: str) -> bool:
        """尝试加载配置文件"""
        try:
            if not os.path.exists(filename):
                return False
            
            with open(filename, 'r', encoding='utf-8') as f:
                self.subscriptions = json.load(f)
            
            # 验证配置完整性
            if not isinstance(self.subscriptions, dict):
                raise ValueError("配置格式不正确")
            
            print(f"✅ 加载配置成功: {len(self.subscriptions)} 个订阅源")
            return True
            
        except Exception as e:
            self.log_error(f"加载配置失败 {filename}: {e}")
            return False
    
    def save_subscriptions_with_backup(self):
        """带备份的配置保存"""
        try:
            # 先备份现有文件
            if os.path.exists(self.config_file):
                import shutil
                shutil.copy2(self.config_file, self.backup_file)
            
            # 保存新配置
            with open(self.config_file, 'w', encoding='utf-8') as f:
                json.dump(self.subscriptions, f, ensure_ascii=False, indent=2)
            
            print("💾 配置保存成功")
            return True
            
        except Exception as e:
            self.log_error(f"保存配置失败: {e}")
            return False
    
    def log_error(self, message: str):
        """记录错误日志"""
        from datetime import datetime
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        error_entry = f"[{timestamp}] {message}"
        
        self.error_log.append(error_entry)
        
        # 写入日志文件
        try:
            with open("rss_reader_errors.log", "a", encoding="utf-8") as f:
                f.write(error_entry + "\n")
        except:
            pass  # 忽略日志写入失败
```

### 3. 用户友好的错误信息

```python
class UserFriendlyErrorHandler:
    """用户友好的错误处理器"""
    
    ERROR_MESSAGES = {
        requests.exceptions.Timeout: {
            'message': '网络请求超时',
            'suggestion': '请检查网络连接，或稍后重试'
        },
        requests.exceptions.ConnectionError: {
            'message': '无法连接到服务器',
            'suggestion': '请检查网络连接和URL是否正确'
        },
        json.JSONDecodeError: {
            'message': '配置文件格式错误',
            'suggestion': '配置文件可能已损坏，将使用默认设置'
        },
        FileNotFoundError: {
            'message': '文件不存在',
            'suggestion': '将创建新的配置文件'
        }
    }
    
    @classmethod
    def handle_error(cls, error: Exception, context: str = "") -> bool:
        """处理错误并显示友好信息"""
        error_type = type(error)
        
        if error_type in cls.ERROR_MESSAGES:
            info = cls.ERROR_MESSAGES[error_type]
            print(f"❌ {info['message']}")
            print(f"💡 {info['suggestion']}")
        else:
            print(f"❌ {context}发生未知错误: {error}")
            print("💡 请检查输入并重试，或联系技术支持")
        
        return False
    
    @classmethod
    def with_error_handling(cls, func):
        """装饰器：为函数添加错误处理"""
        def wrapper(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except Exception as e:
                return cls.handle_error(e, func.__name__)
        return wrapper

# 使用装饰器
@UserFriendlyErrorHandler.with_error_handling
def add_subscription_safe(self, name: str, url: str) -> bool:
    """安全的添加订阅源"""
    response = requests.get(url, timeout=10)
    response.raise_for_status()
    
    feed = feedparser.parse(response.content)
    if not feed.entries:
        raise ValueError("RSS源中没有找到文章")
    
    self.subscriptions[name] = url
    self.save_subscriptions()
    return True
```

## 🔄 重试机制实现

### 基础重试机制
```python
import time
import random

def retry_with_backoff(max_retries: int = 3, base_delay: float = 1.0):
    """带退避的重试装饰器"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            last_exception = None
            
            for attempt in range(max_retries):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    last_exception = e
                    
                    if attempt == max_retries - 1:
                        # 最后一次尝试失败
                        raise last_exception
                    
                    # 计算延迟时间（指数退避 + 随机抖动）
                    delay = base_delay * (2 ** attempt) + random.uniform(0, 1)
                    print(f"尝试 {attempt + 1} 失败，{delay:.1f}秒后重试...")
                    time.sleep(delay)
            
            raise last_exception
        return wrapper
    return decorator

# 使用重试机制
@retry_with_backoff(max_retries=3, base_delay=1.0)
def fetch_rss_with_retry(url: str):
    """带重试的RSS获取"""
    response = requests.get(url, timeout=10)
    response.raise_for_status()
    return response
```

### 智能重试策略
```python
class SmartRetryHandler:
    """智能重试处理器"""
    
    RETRYABLE_ERRORS = {
        requests.exceptions.Timeout: True,
        requests.exceptions.ConnectionError: True,
        requests.exceptions.HTTPError: lambda e: 500 <= e.response.status_code < 600
    }
    
    @classmethod
    def should_retry(cls, error: Exception) -> bool:
        """判断是否应该重试"""
        error_type = type(error)
        
        if error_type not in cls.RETRYABLE_ERRORS:
            return False
        
        rule = cls.RETRYABLE_ERRORS[error_type]
        
        if callable(rule):
            return rule(error)
        
        return rule
    
    @classmethod
    def retry_operation(cls, operation, max_retries: int = 3):
        """执行带重试的操作"""
        for attempt in range(max_retries):
            try:
                return operation()
            except Exception as e:
                if not cls.should_retry(e) or attempt == max_retries - 1:
                    raise
                
                delay = 2 ** attempt + random.uniform(0, 1)
                print(f"第 {attempt + 1} 次尝试失败: {e}")
                print(f"等待 {delay:.1f} 秒后重试...")
                time.sleep(delay)
```

## 🧪 错误处理实践练习

### 练习1：完善异常处理
```python
def enhanced_rss_fetcher(url: str) -> Optional[List[Dict]]:
    """增强的RSS获取器 - 练习任务"""
    # TODO: 实现以下功能
    # 1. 多层异常处理
    # 2. 智能重试机制
    # 3. 错误日志记录
    # 4. 性能监控
    # 5. 用户友好的错误提示
    pass
```

### 练习2：断路器模式
```python
class CircuitBreaker:
    """断路器模式实现 - 练习任务"""
    
    def __init__(self, failure_threshold: int = 5, timeout: int = 60):
        # TODO: 实现断路器模式
        # 1. 记录失败次数
        # 2. 在失败过多时"断开"
        # 3. 定期尝试恢复
        # 4. 提供状态查询
        pass
    
    def call(self, func, *args, **kwargs):
        """通过断路器调用函数"""
        # TODO: 实现调用逻辑
        pass
```

### 练习3：监控和告警
```python
class ErrorMonitor:
    """错误监控系统 - 练习任务"""
    
    def __init__(self):
        # TODO: 实现监控系统
        # 1. 错误统计
        # 2. 性能指标
        # 3. 告警机制
        # 4. 报告生成
        pass
    
    def track_error(self, error: Exception, context: str):
        """记录错误"""
        # TODO: 实现错误跟踪
        pass
    
    def generate_report(self) -> Dict:
        """生成错误报告"""
        # TODO: 生成统计报告
        pass
```

## 📊 错误处理检查清单

### 代码质量检查 ✅
- [ ] 每个可能失败的操作都有异常处理
- [ ] 异常处理足够具体（不只是 `except Exception`）
- [ ] 错误信息对用户友好且可操作
- [ ] 有适当的日志记录
- [ ] 资源能够正确释放

### 用户体验检查 ✅
- [ ] 错误信息清晰易懂
- [ ] 提供解决建议
- [ ] 程序不会突然崩溃
- [ ] 有进度指示和状态反馈
- [ ] 支持重试和恢复操作

### 可维护性检查 ✅
- [ ] 错误日志便于调试
- [ ] 异常类型层次清晰
- [ ] 错误处理逻辑可复用
- [ ] 有错误统计和监控
- [ ] 文档说明错误处理策略

---

> 💡 **学习提示**：良好的错误处理是专业软件开发的重要标志。要学会预见可能的错误情况，并为用户提供优雅的处理方案。

> 🚀 **下一步**：学习完错误处理后，建议继续阅读 `08_用户界面设计.md`，了解如何设计用户友好的命令行界面。
